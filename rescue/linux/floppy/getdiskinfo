#!/bin/sh
#
# Create bootstrap information files -- prelude to creating a
#   Bacula Rescue Disk
#
#   Kern Sibbald, December MMII
#      This source distributed under the GPL
#
export LANG=C
di=diskinfo
cwd=`pwd`
host=`uname -s`

case $host in
 Linux)
  ;;
 FreeBSD | SunOS | IRIX)
   echo ""
   echo "This code is not yet adapted to this OS"     
   exit 1
   ;;
 *)
   echo ""
   echo "Unknown operating system type: $host"     
   exit 1
   ;;
esac
if [ ! `whoami` = "root" ] ; then
  echo ""
  echo "You need to be root to run this, otherwise"
  echo "sfdisk produces no output. Continuing anyway ..."
  echo ""
fi

#
#  First collect information
#
rm -rf format.* partition.* $di 
echo "Begin collecting system info ..."
mkdir -p $di
cd $di
mount -l >mount.bsi
mount -l -t ext2 >mount.ext2.bsi
mount -l -t ext3 >mount.ext3.bsi
cp /etc/fstab fstab.bsi
cp /etc/mtab  mtab.bsi     
df -Tl >df.bsi
sfdisk -s >sfdisk.disks.bsi
grep "^/dev/" sfdisk.disks.bsi | sed -n 's%\(^/dev/[A-Za-z]*\):.*$%\1%p' >disks.bsi
for i in `cat disks.bsi`; do
   j=`echo $i | cut -c6-`
   sfdisk -l $i >sfdisk.$j.bsi 
   sfdisk -d $i >sfdisk.make.$j.bsi
done
route -n >route.bsi
ifconfig >ifconfig.bsi
echo "Done collecting info."

#
# Done collecting information
#


echo "Begin creating scripts ..."
#
# First create partitioning script(s)
#
for i in `cat disks.bsi`; do
  j=`echo $i | cut -c6-`
  cat >$cwd/partition.$j <<END_OF_DATA
#!/bin/sh
#
#  Partition disk $i  -- created by getdiskinfo
echo ""
echo "This script will repartition disk $i."
echo ""
echo "IT WILL DESTROY ALL DATA ON DISK $i !!!!"
echo ""
echo -n "Are you sure you want to continue? yes/no: "
read a
if [ x\$a != xyes ] ; then
   exit 1
fi 
echo "Partitioning disk $i"
# zap partition info
dd if=/dev/zero of=$i bs=512 count=2
# repartition
sfdisk $i <$di/sfdisk.make.$j.bsi | less
echo ""
echo "The previous partitioning was:"
cat $di/sfdisk.$j.bsi
#
echo ""
echo "The new partitioning is:"
sfdisk -l $i
echo ""
echo "If the disk is correctly partitioned, you should"
echo "now run the \"format.$j\" script."
echo ""
END_OF_DATA

  chmod 755 $cwd/partition.$j
done
echo "Done making partitioning scripts"

#
# Create formatting script(s)
#
echo "Begin making formatting script(s) ..."
for i in `cat disks.bsi`; do
  j=`echo $i | cut -c6-`
  cat >$cwd/format.$j <<END_OF_DATA
#!/bin/sh
#
#  Format all partitions on disk $i -- created by getdiskinfo
#
echo ""
echo "This script will format all partitions on disk $i."
echo ""
echo "IT WILL DESTROY ALL DATA ON DISK $i !!!!"
echo ""
echo -n "Are you sure you want to continue? yes/no: "
read a
if [ x\$a != xyes ] ; then
   exit 1
fi 
echo "Do you want to do a disk check for bad blocks?"
echo -n "It is recommended, but takes time. yes/no: "
read a
if [ x\$a = xyes ] ; then
   check="-c"
else
   check=
fi
END_OF_DATA

   # Find swap partitions in output from sfdisk
   k=`grep "^$i.*82  Linux swap" sfdisk.$j.bsi | cut -d ' ' -f 1`
   for disk in $k; do
      echo "echo \"Formatting $disk -- swap partition\"" >>$cwd/format.$j
      echo "mkswap $check $disk" >>$cwd/format.$j
      echo "echo \"\"" >>$cwd/format.$j
   done
   # Find ext2 partitions in mount output
   k=`grep "^$i" mount.ext2.bsi | cut -d ' ' -f 1`
   for disk in $k; do
      echo "echo \"Formating $disk -- ext2 partition\"" >>$cwd/format.$j
      label=`grep "^$disk" mount.ext2.bsi | cut -d ' ' -f 7 | cut -c2- | cut -d ] -f 1`
      if [ x$label = x ] ; then
         echo "mke2fs -v \$check $disk" >>$cwd/format.$j
      else
         echo "mke2fs -v \$check -L $label $disk" >>$cwd/format.$j
      fi
      echo "echo \"\"" >>$cwd/format.$j
   done
   # Find ext3 partitions in mount output
   k=`grep "^$i" mount.ext3.bsi | cut -d ' ' -f 1`
   for disk in $k; do
      echo "echo \"Formating $disk -- ext3 partition\"" >>$cwd/format.$j
      label=`grep "^$disk" mount.ext3.bsi | cut -d ' ' -f 7 | cut -c2- | cut -d ] -f 1`
      if [ x$label = x ] ; then
         echo "mke2fs -v -j \$check $disk" >>$cwd/format.$j
      else
         echo "mke2fs -v -j \$check -L $label $disk" >>$cwd/format.$j
      fi
      echo "echo \"\"" >>$cwd/format.$j
   done
   chmod 755 $cwd/format.$j
done

cd $cwd

#
# Create network start script
#
host=`hostname`
ip=`host $host | cut -d ' ' -f 4`
if [ $ip = "out;" ] ; then
  ip=`ifconfig | grep inet | head -1 | sed -n 's/\ \+inet addr:\([0-9]\+\(\.[0-9]\+\)\{3\}\).*/\1/p'`
fi
cat >start_network <<END_OF_DATA
#!/bin/sh
#
#  Start network -- created by getdiskinfo
#
ip=$ip
dev=eth0
ifconfig lo up
ifconfig \$dev up \$ip
route add default gw \$ip dev \$dev
END_OF_DATA

chmod 755 start_network

cat >mount_drives <<END_OF_DATA
#!/bin/sh
#
#  Mount disk drives  -- created by getdiskinfo
#
END_OF_DATA
sed -n 's/\(^.*\)\ on\ \(.*\)\ type.*$/\1 \/mnt\/disk\2/p' $di/mount.ext2.bsi >/tmp/1$$
sed -n 's/\(^.*\)\ on\ \(.*\)\ type.*$/\1 \/mnt\/disk\2/p' $di/mount.ext3.bsi >>/tmp/1$$
sed -n 's/\(^.*\)\ on\ \(.*\)\ type.*$/\1 \/mnt\/disk\2/p' $di/mount.rei.bsi >>/tmp/1$$
# sort so that / is first
sort -k 2 </tmp/1$$ >/tmp/2$$
# output mkdir followed by its mount
sed -n 's/\(^.*\)\ \(.*$\)/mkdir -p \2\nmount \1 \2/p' /tmp/2$$ >>mount_drives
rm -f /tmp/1$$ /tmp/2$$
rm -f /tmp/1$$

chmod 755 mount_drives

# copy sfdisk so we will have it
cp -f /sbin/sfdisk .
echo "Done building scripts."
echo " "
echo "You might want to do a:"
echo " "
echo "chown -R uuuu:gggg *"
echo " "
echo "where uuuu is your userid and gggg is your group"
echo "so that you can access all the files as non-root"
echo " "
